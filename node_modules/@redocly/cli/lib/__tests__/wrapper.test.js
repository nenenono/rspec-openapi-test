"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("../utils");
const process = require("process");
const wrapper_1 = require("../wrapper");
const lint_1 = require("../commands/lint");
const push_1 = require("../commands/push");
jest.mock('node-fetch');
jest.mock('../utils', () => ({
    sendTelemetry: jest.fn(),
    loadConfigAndHandleErrors: jest.fn(),
}));
jest.mock('../commands/lint', () => ({
    handleLint: jest.fn(),
    lintConfigCallback: jest.fn(),
}));
describe('commandWrapper', () => {
    it('should send telemetry if there is "telemetry: on" in the config', () => __awaiter(void 0, void 0, void 0, function* () {
        utils_1.loadConfigAndHandleErrors.mockImplementation(() => {
            return { telemetry: 'on', styleguide: { recommendedFallback: true } };
        });
        process.env.REDOCLY_TELEMETRY = 'on';
        const wrappedHandler = wrapper_1.commandWrapper(lint_1.handleLint);
        yield wrappedHandler({});
        expect(lint_1.handleLint).toHaveBeenCalledTimes(1);
        expect(utils_1.sendTelemetry).toHaveBeenCalledTimes(1);
        expect(utils_1.sendTelemetry).toHaveBeenCalledWith({}, 0, false);
    }));
    it('should NOT send telemetry if there is "telemetry: off" in the config', () => __awaiter(void 0, void 0, void 0, function* () {
        utils_1.loadConfigAndHandleErrors.mockImplementation(() => {
            return { telemetry: 'off', styleguide: { recommendedFallback: true } };
        });
        process.env.REDOCLY_TELEMETRY = 'on';
        const wrappedHandler = wrapper_1.commandWrapper(lint_1.handleLint);
        yield wrappedHandler({});
        expect(lint_1.handleLint).toHaveBeenCalledTimes(1);
        expect(utils_1.sendTelemetry).toHaveBeenCalledTimes(0);
    }));
    it('should pass files from arguments to config', () => __awaiter(void 0, void 0, void 0, function* () {
        const filesToPush = ['test1.yaml', 'test2.yaml'];
        const loadConfigMock = utils_1.loadConfigAndHandleErrors;
        const argv = {
            files: filesToPush,
        };
        yield wrapper_1.commandWrapper(push_1.handlePush)(argv);
        expect(loadConfigMock).toHaveBeenCalledWith(expect.objectContaining({ files: filesToPush }));
    }));
});
