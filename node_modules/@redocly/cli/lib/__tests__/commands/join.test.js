"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const join_1 = require("../../commands/join");
const utils_1 = require("../../utils");
const colorette_1 = require("colorette");
const openapi_core_1 = require("@redocly/openapi-core");
const openapi_core_2 = require("../../__mocks__/@redocly/openapi-core");
const config_1 = require("../fixtures/config");
jest.mock('../../utils');
jest.mock('colorette');
describe('handleJoin fails', () => {
    const colloreteYellowMock = colorette_1.yellow;
    colloreteYellowMock.mockImplementation((string) => string);
    it('should call exitWithError because only one entrypoint', () => __awaiter(void 0, void 0, void 0, function* () {
        yield join_1.handleJoin({ apis: ['first.yaml'] }, {}, 'cli-version');
        expect(utils_1.exitWithError).toHaveBeenCalledWith(`At least 2 apis should be provided. \n\n`);
    }));
    it('should call exitWithError because passed all 3 options for tags', () => __awaiter(void 0, void 0, void 0, function* () {
        yield join_1.handleJoin({
            apis: ['first.yaml', 'second.yaml'],
            'prefix-tags-with-info-prop': 'something',
            'without-x-tag-groups': true,
            'prefix-tags-with-filename': true,
        }, {}, 'cli-version');
        expect(utils_1.exitWithError).toHaveBeenCalledWith(`You use prefix-tags-with-filename, prefix-tags-with-info-prop, without-x-tag-groups together.\nPlease choose only one! \n\n`);
    }));
    it('should call exitWithError because passed all 2 options for tags', () => __awaiter(void 0, void 0, void 0, function* () {
        yield join_1.handleJoin({
            apis: ['first.yaml', 'second.yaml'],
            'without-x-tag-groups': true,
            'prefix-tags-with-filename': true,
        }, {}, 'cli-version');
        expect(utils_1.exitWithError).toHaveBeenCalledWith(`You use prefix-tags-with-filename, without-x-tag-groups together.\nPlease choose only one! \n\n`);
    }));
    it('should call exitWithError because Only OpenAPI 3.0 and OpenAPI 3.1 are supported', () => __awaiter(void 0, void 0, void 0, function* () {
        yield join_1.handleJoin({
            apis: ['first.yaml', 'second.yaml'],
        }, config_1.ConfigFixture, 'cli-version');
        expect(utils_1.exitWithError).toHaveBeenCalledWith('Only OpenAPI 3.0 and OpenAPI 3.1 are supported: undefined \n\n');
    }));
    it('should call exitWithError if mixing OpenAPI 3.0 and 3.1', () => __awaiter(void 0, void 0, void 0, function* () {
        openapi_core_1.detectSpec
            .mockImplementationOnce(() => 'oas3_0')
            .mockImplementationOnce(() => 'oas3_1');
        yield join_1.handleJoin({
            apis: ['first.yaml', 'second.yaml'],
        }, config_1.ConfigFixture, 'cli-version');
        expect(utils_1.exitWithError).toHaveBeenCalledWith('All APIs must use the same OpenAPI version: undefined \n\n');
    }));
    it('should call writeYaml function', () => __awaiter(void 0, void 0, void 0, function* () {
        openapi_core_1.detectSpec.mockReturnValue('oas3_0');
        yield join_1.handleJoin({
            apis: ['first.yaml', 'second.yaml'],
        }, config_1.ConfigFixture, 'cli-version');
        expect(utils_1.writeYaml).toHaveBeenCalledWith(expect.any(Object), 'openapi.yaml', expect.any(Boolean));
    }));
    it('should call writeYaml function for OpenAPI 3.1', () => __awaiter(void 0, void 0, void 0, function* () {
        openapi_core_1.detectSpec.mockReturnValue('oas3_1');
        yield join_1.handleJoin({
            apis: ['first.yaml', 'second.yaml'],
        }, config_1.ConfigFixture, 'cli-version');
        expect(utils_1.writeYaml).toHaveBeenCalledWith(expect.any(Object), 'openapi.yaml', expect.any(Boolean));
    }));
    it('should call writeYaml function with custom output file', () => __awaiter(void 0, void 0, void 0, function* () {
        openapi_core_1.detectSpec.mockReturnValue('oas3_0');
        yield join_1.handleJoin({
            apis: ['first.yaml', 'second.yaml'],
            output: 'output.yml',
        }, config_1.ConfigFixture, 'cli-version');
        expect(utils_1.writeYaml).toHaveBeenCalledWith(expect.any(Object), 'output.yml', expect.any(Boolean));
    }));
    it('should call skipDecorators and skipPreprocessors', () => __awaiter(void 0, void 0, void 0, function* () {
        openapi_core_1.detectSpec.mockReturnValue('oas3_0');
        yield join_1.handleJoin({
            apis: ['first.yaml', 'second.yaml'],
        }, config_1.ConfigFixture, 'cli-version');
        const config = openapi_core_2.loadConfig();
        expect(config.styleguide.skipDecorators).toHaveBeenCalled();
        expect(config.styleguide.skipPreprocessors).toHaveBeenCalled();
    }));
    it('should not call skipDecorators and skipPreprocessors', () => __awaiter(void 0, void 0, void 0, function* () {
        openapi_core_1.detectSpec.mockReturnValue('oas3_0');
        yield join_1.handleJoin({
            apis: ['first.yaml', 'second.yaml'],
            decorate: true,
            preprocess: true,
        }, config_1.ConfigFixture, 'cli-version');
        const config = openapi_core_2.loadConfig();
        expect(config.styleguide.skipDecorators).not.toHaveBeenCalled();
        expect(config.styleguide.skipPreprocessors).not.toHaveBeenCalled();
    }));
});
