"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("../utils");
const openapi_core_1 = require("@redocly/openapi-core");
const colorette_1 = require("colorette");
const fs_1 = require("fs");
const path = require("path");
const process = require("process");
jest.mock('os');
jest.mock('colorette');
jest.mock('fs');
describe('isSubdir', () => {
    it('can correctly determine if subdir', () => {
        [
            ['/foo', '/foo', false],
            ['/foo', '/bar', false],
            ['/foo', '/foobar', false],
            ['/foo', '/foo/bar', true],
            ['/foo', '/foo/../bar', false],
            ['/foo', '/foo/./bar', true],
            ['/bar/../foo', '/foo/bar', true],
            ['/foo', './bar', false],
            ['/foo', '/foo/..bar', true],
        ].forEach(([parent, child, expectRes]) => {
            expect(utils_1.isSubdir(parent, child)).toBe(expectRes);
        });
    });
    it('can correctly determine if subdir for windows-based paths', () => {
        const os = require('os');
        os.platform.mockImplementation(() => 'win32');
        [
            ['C:/Foo', 'C:/Foo/Bar', true],
            ['C:\\Foo', 'C:\\Bar', false],
            ['C:\\Foo', 'D:\\Foo\\Bar', false],
        ].forEach(([parent, child, expectRes]) => {
            expect(utils_1.isSubdir(parent, child)).toBe(expectRes);
        });
    });
    afterEach(() => {
        jest.resetModules();
    });
});
describe('pathToFilename', () => {
    it('should use correct path separator', () => {
        const processedPath = utils_1.pathToFilename('/user/createWithList', '_');
        expect(processedPath).toEqual('user_createWithList');
    });
});
describe('getFallbackApisOrExit', () => {
    it('should find alias by filename', () => __awaiter(void 0, void 0, void 0, function* () {
        fs_1.existsSync.mockImplementationOnce(() => true);
        const entry = yield utils_1.getFallbackApisOrExit(['./test.yaml'], {
            apis: {
                main: {
                    root: 'test.yaml',
                },
            },
        });
        expect(entry).toEqual([{ path: './test.yaml', alias: 'main' }]);
    }));
});
describe('printConfigLintTotals', () => {
    const totalProblemsMock = {
        errors: 1,
        warnings: 0,
        ignored: 0,
    };
    const redColoretteMocks = colorette_1.red;
    const yellowColoretteMocks = colorette_1.yellow;
    beforeEach(() => {
        yellowColoretteMocks.mockImplementation((text) => text);
        redColoretteMocks.mockImplementation((text) => text);
        jest.spyOn(process.stderr, 'write').mockImplementation(() => true);
    });
    it('should print errors if such exist', () => {
        utils_1.printConfigLintTotals(totalProblemsMock);
        expect(process.stderr.write).toHaveBeenCalledWith('❌ Your config has 1 error.\n');
        expect(redColoretteMocks).toHaveBeenCalledWith('❌ Your config has 1 error.\n');
    });
    it('should print warnign and error', () => {
        utils_1.printConfigLintTotals(Object.assign(Object.assign({}, totalProblemsMock), { warnings: 2 }));
        expect(process.stderr.write).toHaveBeenCalledWith('❌ Your config has 1 error and 2 warnings.\n');
        expect(redColoretteMocks).toHaveBeenCalledWith('❌ Your config has 1 error and 2 warnings.\n');
    });
    it('should print warnign if no error', () => {
        utils_1.printConfigLintTotals(Object.assign(Object.assign({}, totalProblemsMock), { errors: 0, warnings: 2 }));
        expect(process.stderr.write).toHaveBeenCalledWith('You have 2 warnings.\n');
        expect(yellowColoretteMocks).toHaveBeenCalledWith('You have 2 warnings.\n');
    });
    it('should print nothing if no error and no warnings', () => {
        const result = utils_1.printConfigLintTotals(Object.assign(Object.assign({}, totalProblemsMock), { errors: 0 }));
        expect(result).toBeUndefined();
        expect(process.stderr.write).toHaveBeenCalledTimes(0);
        expect(yellowColoretteMocks).toHaveBeenCalledTimes(0);
        expect(redColoretteMocks).toHaveBeenCalledTimes(0);
    });
});
describe('getFallbackApisOrExit', () => {
    const redColoretteMocks = colorette_1.red;
    const yellowColoretteMocks = colorette_1.yellow;
    const apis = {
        main: {
            root: 'someFile.yaml',
            styleguide: {},
        },
    };
    const config = { apis };
    beforeEach(() => {
        yellowColoretteMocks.mockImplementation((text) => text);
        redColoretteMocks.mockImplementation((text) => text);
        jest.spyOn(process.stderr, 'write').mockImplementation(() => true);
        jest.spyOn(process, 'exit').mockImplementation();
    });
    afterEach(() => {
        jest.clearAllMocks();
    });
    it('should exit with error because no path provided', () => __awaiter(void 0, void 0, void 0, function* () {
        const apisConfig = {
            apis: {},
        };
        expect.assertions(1);
        try {
            yield utils_1.getFallbackApisOrExit([''], apisConfig);
        }
        catch (e) {
            expect(e.message).toEqual('Path cannot be empty.');
        }
    }));
    it('should error if file from config do not exist', () => __awaiter(void 0, void 0, void 0, function* () {
        fs_1.existsSync.mockImplementationOnce(() => false);
        expect.assertions(3);
        try {
            yield utils_1.getFallbackApisOrExit(undefined, config);
        }
        catch (e) {
            expect(process.stderr.write).toHaveBeenCalledWith('\nsomeFile.yaml does not exist or is invalid.\n\n');
            expect(process.stderr.write).toHaveBeenCalledWith('Please provide a valid path.\n\n');
            expect(e.message).toEqual('Please provide a valid path.');
        }
    }));
    it('should return valid array with results if such file exist', () => __awaiter(void 0, void 0, void 0, function* () {
        fs_1.existsSync.mockImplementationOnce(() => true);
        jest.spyOn(path, 'resolve').mockImplementationOnce((_, path) => path);
        const result = yield utils_1.getFallbackApisOrExit(undefined, config);
        expect(process.stderr.write).toHaveBeenCalledTimes(0);
        expect(process.exit).toHaveBeenCalledTimes(0);
        expect(result).toStrictEqual([
            {
                alias: 'main',
                path: 'someFile.yaml',
            },
        ]);
    }));
    it('should exit with error in case if invalid path provided as args', () => __awaiter(void 0, void 0, void 0, function* () {
        const apisConfig = {
            apis: {},
        };
        fs_1.existsSync.mockImplementationOnce(() => false);
        expect.assertions(3);
        try {
            yield utils_1.getFallbackApisOrExit(['someFile.yaml'], apisConfig);
        }
        catch (e) {
            expect(process.stderr.write).toHaveBeenCalledWith('\nsomeFile.yaml does not exist or is invalid.\n\n');
            expect(process.stderr.write).toHaveBeenCalledWith('Please provide a valid path.\n\n');
            expect(e.message).toEqual('Please provide a valid path.');
        }
    }));
    it('should exit with error in case if invalid 2 path provided as args', () => __awaiter(void 0, void 0, void 0, function* () {
        const apisConfig = {
            apis: {},
        };
        fs_1.existsSync.mockImplementationOnce(() => false);
        expect.assertions(3);
        try {
            yield utils_1.getFallbackApisOrExit(['someFile.yaml', 'someFile2.yaml'], apisConfig);
        }
        catch (e) {
            expect(process.stderr.write).toHaveBeenCalledWith('\nsomeFile.yaml does not exist or is invalid.\n\n');
            expect(process.stderr.write).toHaveBeenCalledWith('Please provide a valid path.\n\n');
            expect(e.message).toEqual('Please provide a valid path.');
        }
    }));
    it('should exit with error if only one file exist ', () => __awaiter(void 0, void 0, void 0, function* () {
        const apisStub = Object.assign(Object.assign({}, apis), { notExist: {
                root: 'notExist.yaml',
                styleguide: {},
            } });
        const configStub = { apis: apisStub };
        const existSyncMock = fs_1.existsSync.mockImplementation((path) => path.endsWith('someFile.yaml'));
        expect.assertions(4);
        try {
            yield utils_1.getFallbackApisOrExit(undefined, configStub);
        }
        catch (e) {
            expect(process.stderr.write).toHaveBeenCalledWith('\nnotExist.yaml does not exist or is invalid.\n\n');
            expect(process.stderr.write).toHaveBeenCalledWith('Please provide a valid path.\n\n');
            expect(process.stderr.write).toHaveBeenCalledTimes(2);
            expect(e.message).toEqual('Please provide a valid path.');
        }
        existSyncMock.mockClear();
    }));
    it('should work ok if it is url passed', () => __awaiter(void 0, void 0, void 0, function* () {
        fs_1.existsSync.mockImplementationOnce(() => false);
        openapi_core_1.isAbsoluteUrl.mockImplementation(() => true);
        const apisConfig = {
            apis: {
                main: {
                    root: 'https://someLinkt/petstore.yaml?main',
                    styleguide: {},
                },
            },
        };
        const result = yield utils_1.getFallbackApisOrExit(undefined, apisConfig);
        expect(process.stderr.write).toHaveBeenCalledTimes(0);
        expect(result).toStrictEqual([
            {
                alias: 'main',
                path: 'https://someLinkt/petstore.yaml?main',
            },
        ]);
    }));
});
describe('langToExt', () => {
    it.each([
        ['php', '.php'],
        ['c#', '.cs'],
        ['shell', '.sh'],
        ['curl', '.sh'],
        ['bash', '.sh'],
        ['javascript', '.js'],
        ['js', '.js'],
        ['python', '.py'],
    ])('should infer file extension from lang - %s', (lang, expected) => {
        expect(utils_1.langToExt(lang)).toBe(expected);
    });
    it('should ignore case when inferring file extension', () => {
        expect(utils_1.langToExt('JavaScript')).toBe('.js');
    });
});
describe('sorTopLevelKeysForOas', () => {
    it('should sort oas3 top level keys', () => {
        const openApi = {
            openapi: '3.0.0',
            components: {},
            security: [],
            tags: [],
            servers: [],
            paths: {},
            info: {},
            externalDocs: {},
            webhooks: [],
            'x-webhooks': [],
            jsonSchemaDialect: '',
        };
        const orderedKeys = [
            'openapi',
            'info',
            'jsonSchemaDialect',
            'servers',
            'security',
            'tags',
            'externalDocs',
            'paths',
            'webhooks',
            'x-webhooks',
            'components',
        ];
        const result = utils_1.sortTopLevelKeysForOas(openApi);
        Object.keys(result).forEach((key, index) => {
            expect(key).toEqual(orderedKeys[index]);
        });
    });
    it('should sort oas2 top level keys', () => {
        const openApi = {
            swagger: '2.0.0',
            security: [],
            tags: [],
            paths: {},
            info: {},
            externalDocs: {},
            host: '',
            basePath: '',
            securityDefinitions: [],
            schemes: [],
            consumes: [],
            parameters: [],
            produces: [],
            definitions: [],
            responses: [],
        };
        const orderedKeys = [
            'swagger',
            'info',
            'host',
            'basePath',
            'schemes',
            'consumes',
            'produces',
            'security',
            'tags',
            'externalDocs',
            'paths',
            'definitions',
            'parameters',
            'responses',
            'securityDefinitions',
        ];
        const result = utils_1.sortTopLevelKeysForOas(openApi);
        Object.keys(result).forEach((key, index) => {
            expect(key).toEqual(orderedKeys[index]);
        });
    });
});
describe('handleErrors', () => {
    const ref = 'openapi/test.yaml';
    const redColoretteMocks = colorette_1.red;
    const blueColoretteMocks = colorette_1.blue;
    beforeEach(() => {
        jest.spyOn(process.stderr, 'write').mockImplementation(() => true);
        jest.spyOn(process, 'exit').mockImplementation((code) => code);
        redColoretteMocks.mockImplementation((text) => text);
        blueColoretteMocks.mockImplementation((text) => text);
    });
    afterEach(() => {
        jest.clearAllMocks();
    });
    it('should handle ResolveError', () => {
        const resolveError = new openapi_core_1.ResolveError(new Error('File not found'));
        expect(() => utils_1.handleError(resolveError, ref)).toThrowError(utils_1.HandledError);
        expect(redColoretteMocks).toHaveBeenCalledTimes(1);
        expect(process.stderr.write).toHaveBeenCalledWith(`Failed to resolve API description at openapi/test.yaml:\n\n  - File not found.\n\n`);
    });
    it('should handle YamlParseError', () => {
        const yamlParseError = new openapi_core_1.YamlParseError(new Error('Invalid yaml'), {});
        expect(() => utils_1.handleError(yamlParseError, ref)).toThrowError(utils_1.HandledError);
        expect(redColoretteMocks).toHaveBeenCalledTimes(1);
        expect(process.stderr.write).toHaveBeenCalledWith(`Failed to parse API description at openapi/test.yaml:\n\n  - Invalid yaml.\n\n`);
    });
    it('should handle CircularJSONNotSupportedError', () => {
        const circularError = new utils_1.CircularJSONNotSupportedError(new Error('Circular json'));
        expect(() => utils_1.handleError(circularError, ref)).toThrowError(utils_1.HandledError);
        expect(process.stderr.write).toHaveBeenCalledWith(`Detected circular reference which can't be converted to JSON.\n` +
            `Try to use ${colorette_1.blue('yaml')} output or remove ${colorette_1.blue('--dereferenced')}.\n\n`);
    });
    it('should handle SyntaxError', () => {
        const testError = new SyntaxError('Unexpected identifier');
        testError.stack = 'test stack';
        expect(() => utils_1.handleError(testError, ref)).toThrowError(utils_1.HandledError);
        expect(process.stderr.write).toHaveBeenCalledWith('Syntax error: Unexpected identifier test stack\n\n');
    });
    it('should throw unknown error', () => {
        const testError = new Error('Test error');
        expect(() => utils_1.handleError(testError, ref)).toThrowError(utils_1.HandledError);
        expect(process.stderr.write).toHaveBeenCalledWith(`Something went wrong when processing openapi/test.yaml:\n\n  - Test error.\n\n`);
    });
});
describe('checkIfRulesetExist', () => {
    beforeEach(() => {
        jest.spyOn(process, 'exit').mockImplementation((code) => code);
    });
    afterEach(() => {
        jest.clearAllMocks();
    });
    it('should throw an error if rules are not provided', () => {
        const rules = {
            oas2: {},
            oas3_0: {},
            oas3_1: {},
            async2: {},
        };
        expect(() => utils_1.checkIfRulesetExist(rules)).toThrowError('⚠️ No rules were configured. Learn how to configure rules: https://redocly.com/docs/cli/rules/');
    });
    it('should not throw an error if rules are provided', () => {
        const rules = {
            oas2: { 'operation-4xx-response': 'error' },
            oas3_0: {},
            oas3_1: {},
        };
        utils_1.checkIfRulesetExist(rules);
    });
});
describe('cleanColors', () => {
    it('should remove colors from string', () => {
        const stringWithColors = `String for ${colorette_1.red('test')}`;
        const result = utils_1.cleanColors(stringWithColors);
        expect(result).not.toMatch(/\x1b\[\d+m/g);
    });
});
describe('cleanArgs', () => {
    beforeEach(() => {
        // @ts-ignore
        openapi_core_1.isAbsoluteUrl = jest.requireActual('@redocly/openapi-core').isAbsoluteUrl;
        // @ts-ignore
        fs_1.existsSync = (value) => jest.requireActual('fs').existsSync(path.resolve(__dirname, value));
        // @ts-ignore
        fs_1.statSync = (value) => jest.requireActual('fs').statSync(path.resolve(__dirname, value));
    });
    afterEach(() => {
        jest.clearAllMocks();
    });
    it('should remove potentially sensitive data from args', () => {
        const testArgs = {
            config: './fixtures/redocly.yaml',
            apis: ['main@v1', 'fixtures/openapi.yaml', 'http://some.url/openapi.yaml'],
            format: 'codeframe',
        };
        expect(utils_1.cleanArgs(testArgs)).toEqual({
            config: 'file-yaml',
            apis: ['api-name@api-version', 'file-yaml', 'http://url'],
            format: 'codeframe',
        });
    });
    it('should remove potentially sensitive data from a push destination', () => {
        const testArgs = {
            destination: '@org/name@version',
        };
        expect(utils_1.cleanArgs(testArgs)).toEqual({
            destination: '@organization/api-name@api-version',
        });
    });
});
describe('cleanRawInput', () => {
    beforeEach(() => {
        // @ts-ignore
        openapi_core_1.isAbsoluteUrl = jest.requireActual('@redocly/openapi-core').isAbsoluteUrl;
        // @ts-ignore
        fs_1.existsSync = (value) => jest.requireActual('fs').existsSync(path.resolve(__dirname, value));
        // @ts-ignore
        fs_1.statSync = (value) => jest.requireActual('fs').statSync(path.resolve(__dirname, value));
    });
    afterEach(() => {
        jest.clearAllMocks();
    });
    it('should remove  potentially sensitive data from raw CLI input', () => {
        const rawInput = [
            'redocly',
            'bundle',
            'api-name@api-version',
            './fixtures/openapi.yaml',
            'http://some.url/openapi.yaml',
            '--config=fixtures/redocly.yaml',
            '--output',
            'fixtures',
        ];
        expect(utils_1.cleanRawInput(rawInput)).toEqual('redocly bundle api-name@api-version file-yaml http://url --config=file-yaml --output folder');
    });
    it('should preserve safe data from raw CLI input', () => {
        const rawInput = [
            'redocly',
            'lint',
            './fixtures/openapi.json',
            '--format',
            'stylish',
            '--extends=minimal',
            '--skip-rule',
            'operation-4xx-response',
        ];
        expect(utils_1.cleanRawInput(rawInput)).toEqual('redocly lint file-json --format stylish --extends=minimal --skip-rule operation-4xx-response');
    });
});
