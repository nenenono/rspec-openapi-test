"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const index_1 = require("../index");
const path = require("path");
const openapiCore = require("@redocly/openapi-core");
const colorette_1 = require("colorette");
const utils = require('../../../utils');
jest.mock('../../../utils', () => (Object.assign(Object.assign({}, jest.requireActual('../../../utils')), { writeYaml: jest.fn() })));
jest.mock('@redocly/openapi-core', () => (Object.assign(Object.assign({}, jest.requireActual('@redocly/openapi-core')), { isRef: jest.fn() })));
describe('#split', () => {
    const openapiDir = 'test';
    const componentsFiles = {};
    it('should split the file and show the success message', () => __awaiter(void 0, void 0, void 0, function* () {
        const filePath = 'packages/cli/src/commands/split/__tests__/fixtures/spec.json';
        jest.spyOn(process.stderr, 'write').mockImplementation(() => true);
        yield index_1.handleSplit({
            api: filePath,
            outDir: openapiDir,
            separator: '_',
        });
        expect(process.stderr.write).toBeCalledTimes(2);
        expect(process.stderr.write.mock.calls[0][0]).toBe(`ðŸª“ Document: ${colorette_1.blue(filePath)} ${colorette_1.green('is successfully split')}
    and all related files are saved to the directory: ${colorette_1.blue(openapiDir)} \n`);
        expect(process.stderr.write.mock.calls[1][0]).toContain(`${filePath}: split processed in <test>ms`);
    }));
    it('should use the correct separator', () => __awaiter(void 0, void 0, void 0, function* () {
        const filePath = 'packages/cli/src/commands/split/__tests__/fixtures/spec.json';
        jest.spyOn(utils, 'pathToFilename').mockImplementation(() => 'newFilePath');
        yield index_1.handleSplit({
            api: filePath,
            outDir: openapiDir,
            separator: '_',
        });
        expect(utils.pathToFilename).toBeCalledWith(expect.anything(), '_');
        utils.pathToFilename.mockRestore();
    }));
    it('should have correct path with paths', () => {
        const openapi = require('./fixtures/spec.json');
        jest.spyOn(openapiCore, 'slash').mockImplementation(() => 'paths/test.yaml');
        jest.spyOn(path, 'relative').mockImplementation(() => 'paths/test.yaml');
        index_1.iteratePathItems(openapi.paths, openapiDir, path.join(openapiDir, 'paths'), componentsFiles, '_');
        expect(openapiCore.slash).toHaveBeenCalledWith('paths/test.yaml');
        expect(path.relative).toHaveBeenCalledWith('test', 'test/paths/test.yaml');
    });
    it('should have correct path with webhooks', () => {
        const openapi = require('./fixtures/webhooks.json');
        jest.spyOn(openapiCore, 'slash').mockImplementation(() => 'webhooks/test.yaml');
        jest.spyOn(path, 'relative').mockImplementation(() => 'webhooks/test.yaml');
        index_1.iteratePathItems(openapi.webhooks, openapiDir, path.join(openapiDir, 'webhooks'), componentsFiles, 'webhook_');
        expect(openapiCore.slash).toHaveBeenCalledWith('webhooks/test.yaml');
        expect(path.relative).toHaveBeenCalledWith('test', 'test/webhooks/test.yaml');
    });
    it('should have correct path with x-webhooks', () => {
        const openapi = require('./fixtures/spec.json');
        jest.spyOn(openapiCore, 'slash').mockImplementation(() => 'webhooks/test.yaml');
        jest.spyOn(path, 'relative').mockImplementation(() => 'webhooks/test.yaml');
        index_1.iteratePathItems(openapi['x-webhooks'], openapiDir, path.join(openapiDir, 'webhooks'), componentsFiles, 'webhook_');
        expect(openapiCore.slash).toHaveBeenCalledWith('webhooks/test.yaml');
        expect(path.relative).toHaveBeenCalledWith('test', 'test/webhooks/test.yaml');
    });
    it('should create correct folder name for code samples', () => __awaiter(void 0, void 0, void 0, function* () {
        const openapi = require('./fixtures/samples.json');
        const fs = require('fs');
        jest.spyOn(fs, 'writeFileSync').mockImplementation(() => { });
        jest.spyOn(utils, 'escapeLanguageName');
        index_1.iteratePathItems(openapi.paths, openapiDir, path.join(openapiDir, 'paths'), componentsFiles, '_');
        expect(utils.escapeLanguageName).nthCalledWith(1, 'C#');
        expect(utils.escapeLanguageName).nthReturnedWith(1, 'C_sharp');
        expect(utils.escapeLanguageName).nthCalledWith(2, 'C/AL');
        expect(utils.escapeLanguageName).nthReturnedWith(2, 'C_AL');
        expect(utils.escapeLanguageName).nthCalledWith(3, 'Visual Basic');
        expect(utils.escapeLanguageName).nthReturnedWith(3, 'VisualBasic');
        expect(utils.escapeLanguageName).toBeCalledTimes(3);
        utils.escapeLanguageName.mockRestore();
    }));
});
