"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.cleanRawInput = exports.cleanArgs = exports.sendTelemetry = exports.cleanColors = exports.checkIfRulesetExist = exports.sortTopLevelKeysForOas = exports.loadConfigAndHandleErrors = exports.isSubdir = exports.exitWithError = exports.printUnusedWarnings = exports.getOutputFileName = exports.printConfigLintTotals = exports.printLintTotals = exports.HandledError = exports.handleError = exports.pluralize = exports.writeYaml = exports.readYaml = exports.promptUser = exports.saveBundle = exports.dumpBundle = exports.CircularJSONNotSupportedError = exports.langToExt = exports.escapeLanguageName = exports.pathToFilename = exports.printExecutionTime = exports.getExecutionTime = exports.getFallbackApisOrExit = void 0;
const fetch_with_timeout_1 = require("./fetch-with-timeout");
const path_1 = require("path");
const colorette_1 = require("colorette");
const perf_hooks_1 = require("perf_hooks");
const glob = require("glob");
const fs = require("fs");
const readline = require("readline");
const stream_1 = require("stream");
const child_process_1 = require("child_process");
const openapi_core_1 = require("@redocly/openapi-core");
const types_1 = require("./types");
const utils_1 = require("@redocly/openapi-core/lib/utils");
const update_version_notifier_1 = require("./update-version-notifier");
const push_1 = require("./commands/push");
function getFallbackApisOrExit(argsApis, config) {
    return __awaiter(this, void 0, void 0, function* () {
        const { apis } = config;
        const shouldFallbackToAllDefinitions = !isNotEmptyArray(argsApis) && apis && Object.keys(apis).length > 0;
        const res = shouldFallbackToAllDefinitions
            ? fallbackToAllDefinitions(apis, config)
            : yield expandGlobsInEntrypoints(argsApis, config);
        const filteredInvalidEntrypoints = res.filter(({ path }) => !isApiPathValid(path));
        if (isNotEmptyArray(filteredInvalidEntrypoints)) {
            for (const { path } of filteredInvalidEntrypoints) {
                process.stderr.write(colorette_1.yellow(`\n${path_1.relative(process.cwd(), path)} ${colorette_1.red(`does not exist or is invalid.\n\n`)}`));
            }
            exitWithError('Please provide a valid path.');
        }
        return res;
    });
}
exports.getFallbackApisOrExit = getFallbackApisOrExit;
function getConfigDirectory(config) {
    return config.configFile ? path_1.dirname(config.configFile) : process.cwd();
}
function isNotEmptyArray(args) {
    return Array.isArray(args) && !!args.length;
}
function isApiPathValid(apiPath) {
    if (!apiPath.trim()) {
        exitWithError('Path cannot be empty.');
        return;
    }
    return fs.existsSync(apiPath) || openapi_core_1.isAbsoluteUrl(apiPath) ? apiPath : undefined;
}
function fallbackToAllDefinitions(apis, config) {
    return Object.entries(apis).map(([alias, { root }]) => ({
        path: openapi_core_1.isAbsoluteUrl(root) ? root : path_1.resolve(getConfigDirectory(config), root),
        alias,
    }));
}
function getAliasOrPath(config, aliasOrPath) {
    var _a, _b, _c;
    return config.apis[aliasOrPath]
        ? { path: (_a = config.apis[aliasOrPath]) === null || _a === void 0 ? void 0 : _a.root, alias: aliasOrPath }
        : {
            path: aliasOrPath,
            // find alias by path, take the first match
            alias: (_c = (_b = Object.entries(config.apis).find(([_alias, api]) => {
                return path_1.resolve(api.root) === path_1.resolve(aliasOrPath);
            })) === null || _b === void 0 ? void 0 : _b[0]) !== null && _c !== void 0 ? _c : undefined,
        };
}
function expandGlobsInEntrypoints(args, config) {
    return __awaiter(this, void 0, void 0, function* () {
        return (yield Promise.all(args.map((aliasOrPath) => __awaiter(this, void 0, void 0, function* () {
            return glob.hasMagic(aliasOrPath) && !openapi_core_1.isAbsoluteUrl(aliasOrPath)
                ? (yield glob.__promisify__(aliasOrPath)).map((g) => getAliasOrPath(config, g))
                : getAliasOrPath(config, aliasOrPath);
        })))).flat();
    });
}
function getExecutionTime(startedAt) {
    return process.env.NODE_ENV === 'test'
        ? '<test>ms'
        : `${Math.ceil(perf_hooks_1.performance.now() - startedAt)}ms`;
}
exports.getExecutionTime = getExecutionTime;
function printExecutionTime(commandName, startedAt, api) {
    const elapsed = getExecutionTime(startedAt);
    process.stderr.write(colorette_1.gray(`\n${api}: ${commandName} processed in ${elapsed}\n\n`));
}
exports.printExecutionTime = printExecutionTime;
function pathToFilename(path, pathSeparator) {
    return path
        .replace(/~1/g, '/')
        .replace(/~0/g, '~')
        .replace(/^\//, '')
        .replace(/\//g, pathSeparator);
}
exports.pathToFilename = pathToFilename;
function escapeLanguageName(lang) {
    return lang.replace(/#/g, '_sharp').replace(/\//, '_').replace(/\s/g, '');
}
exports.escapeLanguageName = escapeLanguageName;
function langToExt(lang) {
    const langObj = {
        php: '.php',
        'c#': '.cs',
        shell: '.sh',
        curl: '.sh',
        bash: '.sh',
        javascript: '.js',
        js: '.js',
        python: '.py',
    };
    return langObj[lang.toLowerCase()];
}
exports.langToExt = langToExt;
class CircularJSONNotSupportedError extends Error {
    constructor(originalError) {
        super(originalError.message);
        this.originalError = originalError;
        // Set the prototype explicitly.
        Object.setPrototypeOf(this, CircularJSONNotSupportedError.prototype);
    }
}
exports.CircularJSONNotSupportedError = CircularJSONNotSupportedError;
function dumpBundle(obj, format, dereference) {
    if (format === 'json') {
        try {
            return JSON.stringify(obj, null, 2);
        }
        catch (e) {
            if (e.message.indexOf('circular') > -1) {
                throw new CircularJSONNotSupportedError(e);
            }
            throw e;
        }
    }
    else {
        return openapi_core_1.stringifyYaml(obj, {
            noRefs: !dereference,
            lineWidth: -1,
        });
    }
}
exports.dumpBundle = dumpBundle;
function saveBundle(filename, output) {
    fs.mkdirSync(path_1.dirname(filename), { recursive: true });
    fs.writeFileSync(filename, output);
}
exports.saveBundle = saveBundle;
function promptUser(query, hideUserInput = false) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve) => {
            let output = process.stdout;
            let isOutputMuted = false;
            if (hideUserInput) {
                output = new stream_1.Writable({
                    write: (chunk, encoding, callback) => {
                        if (!isOutputMuted) {
                            process.stdout.write(chunk, encoding);
                        }
                        callback();
                    },
                });
            }
            const rl = readline.createInterface({
                input: process.stdin,
                output,
                terminal: true,
                historySize: hideUserInput ? 0 : 30,
            });
            rl.question(`${query}:\n\n  `, (answer) => {
                rl.close();
                resolve(answer);
            });
            isOutputMuted = hideUserInput;
        });
    });
}
exports.promptUser = promptUser;
function readYaml(filename) {
    return openapi_core_1.parseYaml(fs.readFileSync(filename, 'utf-8'), { filename });
}
exports.readYaml = readYaml;
function writeYaml(data, filename, noRefs = false) {
    const content = openapi_core_1.stringifyYaml(data, { noRefs });
    if (process.env.NODE_ENV === 'test') {
        process.stderr.write(content);
        return;
    }
    fs.mkdirSync(path_1.dirname(filename), { recursive: true });
    fs.writeFileSync(filename, content);
}
exports.writeYaml = writeYaml;
function pluralize(label, num) {
    if (label.endsWith('is')) {
        [label] = label.split(' ');
        return num === 1 ? `${label} is` : `${label}s are`;
    }
    return num === 1 ? `${label}` : `${label}s`;
}
exports.pluralize = pluralize;
function handleError(e, ref) {
    var _a, _b;
    switch (e.constructor) {
        case HandledError: {
            throw e;
        }
        case openapi_core_1.ResolveError:
            return exitWithError(`Failed to resolve API description at ${ref}:\n\n  - ${e.message}.`);
        case openapi_core_1.YamlParseError:
            return exitWithError(`Failed to parse API description at ${ref}:\n\n  - ${e.message}.`);
        case CircularJSONNotSupportedError: {
            return exitWithError(`Detected circular reference which can't be converted to JSON.\n` +
                `Try to use ${colorette_1.blue('yaml')} output or remove ${colorette_1.blue('--dereferenced')}.`);
        }
        case SyntaxError:
            return exitWithError(`Syntax error: ${e.message} ${(_b = (_a = e.stack) === null || _a === void 0 ? void 0 : _a.split('\n\n')) === null || _b === void 0 ? void 0 : _b[0]}`);
        default: {
            exitWithError(`Something went wrong when processing ${ref}:\n\n  - ${e.message}.`);
        }
    }
}
exports.handleError = handleError;
class HandledError extends Error {
}
exports.HandledError = HandledError;
function printLintTotals(totals, definitionsCount) {
    const ignored = totals.ignored
        ? colorette_1.yellow(`${totals.ignored} ${pluralize('problem is', totals.ignored)} explicitly ignored.\n\n`)
        : '';
    if (totals.errors > 0) {
        process.stderr.write(colorette_1.red(`❌ Validation failed with ${totals.errors} ${pluralize('error', totals.errors)}${totals.warnings > 0
            ? ` and ${totals.warnings} ${pluralize('warning', totals.warnings)}`
            : ''}.\n${ignored}`));
    }
    else if (totals.warnings > 0) {
        process.stderr.write(colorette_1.green(`Woohoo! Your API ${pluralize('description is', definitionsCount)} valid. 🎉\n`));
        process.stderr.write(colorette_1.yellow(`You have ${totals.warnings} ${pluralize('warning', totals.warnings)}.\n${ignored}`));
    }
    else {
        process.stderr.write(colorette_1.green(`Woohoo! Your API ${pluralize('description is', definitionsCount)} valid. 🎉\n${ignored}`));
    }
    if (totals.errors > 0) {
        process.stderr.write(colorette_1.gray(`run \`redocly lint --generate-ignore-file\` to add all problems to the ignore file.\n`));
    }
    process.stderr.write('\n');
}
exports.printLintTotals = printLintTotals;
function printConfigLintTotals(totals) {
    if (totals.errors > 0) {
        process.stderr.write(colorette_1.red(`❌ Your config has ${totals.errors} ${pluralize('error', totals.errors)}${totals.warnings > 0
            ? ` and ${totals.warnings} ${pluralize('warning', totals.warnings)}`
            : ''}.\n`));
    }
    else if (totals.warnings > 0) {
        process.stderr.write(colorette_1.yellow(`You have ${totals.warnings} ${pluralize('warning', totals.warnings)}.\n`));
    }
}
exports.printConfigLintTotals = printConfigLintTotals;
function getOutputFileName(entrypoint, entries, output, ext) {
    if (!output) {
        return { outputFile: 'stdout', ext: ext || 'yaml' };
    }
    let outputFile = output;
    if (entries > 1) {
        ext = ext || path_1.extname(entrypoint).substring(1);
        if (!types_1.outputExtensions.includes(ext)) {
            throw new Error(`Invalid file extension: ${ext}.`);
        }
        outputFile = path_1.join(output, path_1.basename(entrypoint, path_1.extname(entrypoint))) + '.' + ext;
    }
    else {
        if (output) {
            ext = ext || path_1.extname(output).substring(1);
        }
        ext = ext || path_1.extname(entrypoint).substring(1);
        if (!types_1.outputExtensions.includes(ext)) {
            throw new Error(`Invalid file extension: ${ext}.`);
        }
        outputFile = path_1.join(path_1.dirname(outputFile), path_1.basename(outputFile, path_1.extname(outputFile))) + '.' + ext;
    }
    return { outputFile, ext };
}
exports.getOutputFileName = getOutputFileName;
function printUnusedWarnings(config) {
    const { preprocessors, rules, decorators } = config.getUnusedRules();
    if (rules.length) {
        process.stderr.write(colorette_1.yellow(`[WARNING] Unused rules found in ${colorette_1.blue(config.configFile || '')}: ${rules.join(', ')}.\n`));
    }
    if (preprocessors.length) {
        process.stderr.write(colorette_1.yellow(`[WARNING] Unused preprocessors found in ${colorette_1.blue(config.configFile || '')}: ${preprocessors.join(', ')}.\n`));
    }
    if (decorators.length) {
        process.stderr.write(colorette_1.yellow(`[WARNING] Unused decorators found in ${colorette_1.blue(config.configFile || '')}: ${decorators.join(', ')}.\n`));
    }
    if (rules.length || preprocessors.length) {
        process.stderr.write(`Check the spelling and verify the added plugin prefix.\n`);
    }
}
exports.printUnusedWarnings = printUnusedWarnings;
function exitWithError(message) {
    process.stderr.write(colorette_1.red(message) + '\n\n');
    throw new HandledError(message);
}
exports.exitWithError = exitWithError;
/**
 * Checks if dir is subdir of parent
 */
function isSubdir(parent, dir) {
    const relativePath = path_1.relative(parent, dir);
    return !!relativePath && !/^..($|\/)/.test(relativePath) && !path_1.isAbsolute(relativePath);
}
exports.isSubdir = isSubdir;
function loadConfigAndHandleErrors(options = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            return yield openapi_core_1.loadConfig(options);
        }
        catch (e) {
            handleError(e, '');
        }
    });
}
exports.loadConfigAndHandleErrors = loadConfigAndHandleErrors;
function sortTopLevelKeysForOas(document) {
    if ('swagger' in document) {
        return sortOas2Keys(document);
    }
    return sortOas3Keys(document);
}
exports.sortTopLevelKeysForOas = sortTopLevelKeysForOas;
function sortOas2Keys(document) {
    const orderedKeys = [
        'swagger',
        'info',
        'host',
        'basePath',
        'schemes',
        'consumes',
        'produces',
        'security',
        'tags',
        'externalDocs',
        'paths',
        'definitions',
        'parameters',
        'responses',
        'securityDefinitions',
    ];
    const result = {};
    for (const key of orderedKeys) {
        if (document.hasOwnProperty(key)) {
            result[key] = document[key];
        }
    }
    // merge any other top-level keys (e.g. vendor extensions)
    return Object.assign(result, document);
}
function sortOas3Keys(document) {
    const orderedKeys = [
        'openapi',
        'info',
        'jsonSchemaDialect',
        'servers',
        'security',
        'tags',
        'externalDocs',
        'paths',
        'webhooks',
        'x-webhooks',
        'components',
    ];
    const result = {};
    for (const key of orderedKeys) {
        if (document.hasOwnProperty(key)) {
            result[key] = document[key];
        }
    }
    // merge any other top-level keys (e.g. vendor extensions)
    return Object.assign(result, document);
}
function checkIfRulesetExist(rules) {
    const ruleset = Object.assign(Object.assign(Object.assign({}, rules.oas2), rules.oas3_0), rules.oas3_0);
    if (utils_1.isEmptyObject(ruleset)) {
        exitWithError('⚠️ No rules were configured. Learn how to configure rules: https://redocly.com/docs/cli/rules/');
    }
}
exports.checkIfRulesetExist = checkIfRulesetExist;
function cleanColors(input) {
    // eslint-disable-next-line no-control-regex
    return input.replace(/\x1b\[\d+m/g, '');
}
exports.cleanColors = cleanColors;
function sendTelemetry(argv, exit_code, has_config) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            if (!argv) {
                return;
            }
            const { _: [command], $0: _ } = argv, args = __rest(argv, ["_", "$0"]);
            const event_time = new Date().toISOString();
            const redoclyClient = new openapi_core_1.RedoclyClient();
            const logged_in = redoclyClient.hasTokens();
            const data = {
                event: 'cli_command',
                event_time,
                logged_in,
                command,
                arguments: cleanArgs(args),
                node_version: process.version,
                npm_version: child_process_1.execSync('npm -v').toString().replace('\n', ''),
                version: update_version_notifier_1.version,
                exit_code,
                environment: process.env.REDOCLY_ENVIRONMENT,
                environment_ci: process.env.CI,
                raw_input: cleanRawInput(process.argv.slice(2)),
                has_config,
            };
            yield fetch_with_timeout_1.default(`https://api.redocly.com/registry/telemetry/cli`, {
                method: 'POST',
                headers: {
                    'content-type': 'application/json',
                },
                body: JSON.stringify(data),
            });
        }
        catch (err) {
            // Do nothing.
        }
    });
}
exports.sendTelemetry = sendTelemetry;
function isFile(value) {
    return fs.existsSync(value) && fs.statSync(value).isFile();
}
function isDirectory(value) {
    return fs.existsSync(value) && fs.statSync(value).isDirectory();
}
function cleanString(value) {
    if (!value) {
        return value;
    }
    if (openapi_core_1.isAbsoluteUrl(value)) {
        return value.split('://')[0] + '://url';
    }
    if (isFile(value)) {
        return value.replace(/.+\.([^.]+)$/, (_, ext) => 'file-' + ext);
    }
    if (isDirectory(value)) {
        return 'folder';
    }
    if (push_1.DESTINATION_REGEX.test(value)) {
        return value.startsWith('@') ? '@organization/api-name@api-version' : 'api-name@api-version';
    }
    return value;
}
function cleanArgs(args) {
    const keysToClean = ['organization', 'o'];
    const result = {};
    for (const [key, value] of Object.entries(args)) {
        if (keysToClean.includes(key)) {
            result[key] = '***';
        }
        else if (typeof value === 'string') {
            result[key] = cleanString(value);
        }
        else if (Array.isArray(value)) {
            result[key] = value.map(cleanString);
        }
        else {
            result[key] = value;
        }
    }
    return result;
}
exports.cleanArgs = cleanArgs;
function cleanRawInput(argv) {
    return argv.map((entry) => entry.split('=').map(cleanString).join('=')).join(' ');
}
exports.cleanRawInput = cleanRawInput;
