"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.cacheLatestVersion = exports.notifyUpdateCliVersion = exports.name = exports.version = void 0;
const os_1 = require("os");
const path_1 = require("path");
const fs_1 = require("fs");
const semver_1 = require("semver");
const fetch_with_timeout_1 = require("./fetch-with-timeout");
const colorette_1 = require("colorette");
const utils_1 = require("./utils");
_a = require('../package.json'), exports.version = _a.version, exports.name = _a.name;
const VERSION_CACHE_FILE = 'redocly-cli-version';
const SPACE_TO_BORDER = 4;
const INTERVAL_TO_CHECK = 1000 * 60 * 60 * 12;
const SHOULD_NOT_NOTIFY = process.env.NODE_ENV === 'test' || process.env.CI || !!process.env.LAMBDA_TASK_ROOT;
const notifyUpdateCliVersion = () => {
    if (SHOULD_NOT_NOTIFY) {
        return;
    }
    try {
        const latestVersion = fs_1.readFileSync(path_1.join(os_1.tmpdir(), VERSION_CACHE_FILE)).toString();
        if (isNewVersionAvailable(exports.version, latestVersion)) {
            renderUpdateBanner(exports.version, latestVersion);
        }
    }
    catch (e) {
        return;
    }
};
exports.notifyUpdateCliVersion = notifyUpdateCliVersion;
const isNewVersionAvailable = (current, latest) => semver_1.compare(current, latest) < 0;
const getLatestVersion = (packageName) => __awaiter(void 0, void 0, void 0, function* () {
    const latestUrl = `http://registry.npmjs.org/${packageName}/latest`;
    const response = yield fetch_with_timeout_1.default(latestUrl);
    if (!response)
        return;
    const info = yield response.json();
    return info.version;
});
const cacheLatestVersion = () => {
    if (!isNeedToBeCached() || SHOULD_NOT_NOTIFY) {
        return;
    }
    getLatestVersion(exports.name)
        .then((version) => {
        if (version) {
            const lastCheckFile = path_1.join(os_1.tmpdir(), VERSION_CACHE_FILE);
            fs_1.writeFileSync(lastCheckFile, version);
        }
    })
        .catch(() => { });
};
exports.cacheLatestVersion = cacheLatestVersion;
const renderUpdateBanner = (current, latest) => {
    const messageLines = [
        `A new version of ${colorette_1.cyan('Redocly CLI')} (${colorette_1.green(latest)}) is available.`,
        `Update now: \`${colorette_1.cyan('npm i -g @redocly/cli@latest')}\`.`,
        `Changelog: https://redocly.com/docs/cli/changelog/`,
    ];
    const maxLength = Math.max(...messageLines.map((line) => utils_1.cleanColors(line).length));
    const border = colorette_1.yellow('═'.repeat(maxLength + SPACE_TO_BORDER));
    const banner = `
    ${colorette_1.yellow('╔' + border + '╗')}
    ${colorette_1.yellow('║' + ' '.repeat(maxLength + SPACE_TO_BORDER) + '║')}
    ${messageLines
        .map((line, index) => {
        return getLineWithPadding(maxLength, line, index);
    })
        .join('\n')}
    ${colorette_1.yellow('║' + ' '.repeat(maxLength + SPACE_TO_BORDER) + '║')}
    ${colorette_1.yellow('╚' + border + '╝')}
  `;
    process.stderr.write(banner);
};
const getLineWithPadding = (maxLength, line, index) => {
    const padding = ' '.repeat(maxLength - utils_1.cleanColors(line).length);
    const extraSpaces = index !== 0 ? ' '.repeat(SPACE_TO_BORDER) : '';
    return `${extraSpaces}${colorette_1.yellow('║')}  ${line}${padding}  ${colorette_1.yellow('║')}`;
};
const isNeedToBeCached = () => {
    try {
        // Last version from npm is stored in a file in the OS temp folder
        const versionFile = path_1.join(os_1.tmpdir(), VERSION_CACHE_FILE);
        if (!fs_1.existsSync(versionFile)) {
            return true;
        }
        const now = new Date().getTime();
        const stats = fs_1.statSync(versionFile);
        const lastCheck = stats.mtime.getTime();
        return now - lastCheck >= INTERVAL_TO_CHECK;
    }
    catch (e) {
        return false;
    }
};
